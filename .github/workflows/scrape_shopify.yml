name: Run Shopify Scraper and Upload to Google Drive

on:
  schedule:
    # Runs every day at 00:00 UTC (which is 5:30 AM IST on the next day)
    # Adjust as needed. For example, if you want it to run daily at 8:00 AM IST,
    # that would be 2:30 AM UTC (30 2 * * *).
    - cron: '30 3 * * *'
on:
    workflow_dispatch:
    # Allows you to manually trigger the workflow from the GitHub UI

jobs:
  scrape_and_upload:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9' # Or your preferred Python version

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install PyDrive2 # Ensure PyDrive2 is installed here if not in requirements.txt

      - name: Run scraper script and capture filename
        id: run_script
        run: |
          # --- IMPORTANT: Changed script name here ---
          python shopify_reviews_2.py
          # Capture the latest generated CSV filename.
          # This assumes your script generates CSVs directly in the root of the action runner's workspace.
          # The 'ls -t *.csv | head -1' command gets the most recently modified CSV file.
          LATEST_CSV=$(ls -t *.csv | head -1)
          if [ -z "$LATEST_CSV" ]; then
            echo "Error: No CSV file was generated by shopify_reviews_2.py."
            exit 1
          fi
          echo "Generated CSV: $LATEST_CSV"
          # Set an output for the next step (using the new GITHUB_OUTPUT method)
          echo "csv_file=$LATEST_CSV" >> $GITHUB_OUTPUT

      - name: Setup PyDrive2 credentials for Google Drive Upload
        run: |
          mkdir -p ~/.config/pydrive
          # Write the service account key from GitHub secret to a file
          echo '${{ secrets.GDRIVE_SERVICE_ACCOUNT_KEY }}' > ~/.config/pydrive/credentials.json
        env:
          GDRIVE_SERVICE_ACCOUNT_KEY: ${{ secrets.GDRIVE_SERVICE_ACCOUNT_KEY }}

      - name: Upload CSV to Google Drive
        run: |
          python -c "
import os
from pydrive2.auth import GoogleAuth
from pydrive2.drive import GoogleDrive

gauth = GoogleAuth()
# Load credentials from the service account JSON file
gauth.DEFAULT_SETTINGS['client_config_file'] = os.path.expanduser('~/.config/pydrive/credentials.json')
gauth.AuthFromServiceAccount()
drive = GoogleDrive(gauth)

# The specific Google Drive folder ID where files will be uploaded
folder_id = '15gVrByonzFvBMGxJ4NUvVXzCgEUVB1Se' # <--- Your Google Drive Folder ID

# Get the filename from the previous step's output using environment variable
csv_filename = os.getenv('CSV_FILENAME')

# Check if csv_filename is empty or the file doesn't exist
if not csv_filename or not os.path.exists(csv_filename):
    print(f'Error: CSV file not found or filename not provided: {csv_filename}')
    exit(1)

print(f'Attempting to upload {csv_filename} to Google Drive folder ID: {folder_id}')

# List files in the target folder to check for existing file with the same name
# This approach updates an existing file with the same title, otherwise creates a new one.
file_list = drive.ListFile({'q': f\"'{folder_id}' in parents and trashed=false\"}).GetList()
existing_file_id = None
for file_in_drive in file_list:
    if file_in_drive['title'] == csv_filename:
        existing_file_id = file_in_drive['id']
        break

if existing_file_id:
    # Update existing file
    print(f'Updating existing file: {csv_filename} (ID: {existing_file_id})')
    file_to_upload = drive.CreateFile({'id': existing_file_id})
    file_to_upload.SetContentFile(csv_filename)
    file_to_upload.Upload()
else:
    # Create new file
    print(f'Creating new file: {csv_filename}')
    file_to_upload = drive.CreateFile({
        'title': csv_filename,
        'parents': [{'id': folder_id}]
    })
    file_to_upload.SetContentFile(csv_filename)
    file_to_upload.Upload()

print('Upload successful!')
              "
        env:
          # Pass the output from 'run_script' step as an environment variable to this step's Python script
          CSV_FILENAME: ${{ steps.run_script.outputs.csv_file }}
